# Contract: WeekViewModel

**Feature Branch**: `003-week-view`
**Date**: 2026-01-02

## Overview

The WeekViewModel manages the state and logic for the Week View screen. It follows the MVI (Model-View-Intent) pattern with unidirectional data flow.

---

## Interface Definition

```kotlin
package org.epoque.tandem.presentation.week

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.StateFlow

/**
 * ViewModel contract for the Week View screen.
 */
interface WeekViewModelContract {

    /**
     * Observable UI state. Collect in the Composable.
     */
    val uiState: StateFlow<WeekUiState>

    /**
     * One-time side effects. Collect in LaunchedEffect.
     */
    val sideEffects: Flow<WeekSideEffect>

    /**
     * Handle user events from the UI.
     */
    fun onEvent(event: WeekEvent)
}
```

---

## Implementation Signature

```kotlin
package org.epoque.tandem.presentation.week

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import org.epoque.tandem.domain.model.OwnerType
import org.epoque.tandem.domain.model.TaskStatus
import org.epoque.tandem.domain.repository.TaskRepository
import org.epoque.tandem.domain.repository.WeekRepository
import org.epoque.tandem.presentation.week.model.Segment
import org.epoque.tandem.presentation.week.model.TaskUiModel
import org.epoque.tandem.presentation.week.model.WeekInfo

class WeekViewModel(
    private val taskRepository: TaskRepository,
    private val weekRepository: WeekRepository,
    private val segmentPreferences: SegmentPreferences,
    private val userProvider: UserProvider  // From Feature 001
) : ViewModel(), WeekViewModelContract {

    private val _uiState = MutableStateFlow(WeekUiState())
    override val uiState: StateFlow<WeekUiState> = _uiState.asStateFlow()

    private val _sideEffects = Channel<WeekSideEffect>(Channel.BUFFERED)
    override val sideEffects: Flow<WeekSideEffect> = _sideEffects.receiveAsFlow()

    init {
        loadInitialData()
        observeSegmentPreference()
        observeTasks()
    }

    override fun onEvent(event: WeekEvent) {
        when (event) {
            // Handle each event type
        }
    }
}
```

---

## Event Handling

### SegmentSelected

```kotlin
private fun handleSegmentSelected(segment: Segment) {
    viewModelScope.launch {
        segmentPreferences.setSelectedSegment(segment)
        // State updates reactively via observeSegmentPreference()
    }
}
```

### TaskCheckboxTapped

```kotlin
private fun handleTaskCheckboxTapped(taskId: String) {
    viewModelScope.launch {
        val task = taskRepository.getTaskById(taskId) ?: return@launch

        if (task.isRepeating) {
            val newCount = task.repeatCompleted + 1
            if (newCount >= (task.repeatTarget ?: 0)) {
                taskRepository.updateTaskStatus(taskId, TaskStatus.COMPLETED)
            }
            taskRepository.incrementRepeatCount(taskId)
        } else {
            val newStatus = if (task.status == TaskStatus.COMPLETED) {
                TaskStatus.PENDING
            } else {
                TaskStatus.COMPLETED
            }
            taskRepository.updateTaskStatus(taskId, newStatus)
        }

        _sideEffects.send(WeekSideEffect.TriggerHapticFeedback)
    }
}
```

### QuickAddSubmitted

```kotlin
private fun handleQuickAddSubmitted() {
    val title = _uiState.value.quickAddText.trim()

    if (title.isEmpty()) {
        _uiState.update { it.copy(quickAddError = "Task title cannot be empty") }
        return
    }

    viewModelScope.launch {
        val userId = userProvider.currentUserId
        val weekId = weekRepository.getCurrentWeekId()

        val ownerType = when (_uiState.value.selectedSegment) {
            Segment.YOU -> OwnerType.SELF
            Segment.SHARED -> OwnerType.SHARED
            Segment.PARTNER -> return@launch // Should not happen
        }

        val task = Task(
            id = "",  // Generated by repository
            title = title,
            notes = null,
            ownerId = userId,
            ownerType = ownerType,
            weekId = weekId,
            status = TaskStatus.PENDING,
            createdBy = userId,
            repeatTarget = null,
            repeatCompleted = 0,
            linkedGoalId = null,
            reviewNote = null,
            rolledFromWeekId = null,
            createdAt = Instant.DISTANT_PAST,  // Set by repository
            updatedAt = Instant.DISTANT_PAST   // Set by repository
        )

        taskRepository.createTask(task)

        _uiState.update { it.copy(quickAddText = "", quickAddError = null) }
        _sideEffects.send(WeekSideEffect.ClearFocus)
    }
}
```

### TaskTapped

```kotlin
private fun handleTaskTapped(taskId: String) {
    _uiState.update {
        it.copy(
            selectedTaskId = taskId,
            showDetailSheet = true
        )
    }
}
```

### AddTaskSubmitted

```kotlin
private fun handleAddTaskSubmitted(title: String, notes: String?, ownerType: OwnerType) {
    if (title.isBlank()) {
        // Show validation error in sheet
        return
    }

    viewModelScope.launch {
        val userId = userProvider.currentUserId
        val weekId = weekRepository.getCurrentWeekId()

        val task = Task(
            id = "",
            title = title.trim(),
            notes = notes?.trim()?.takeIf { it.isNotEmpty() },
            ownerId = userId,
            ownerType = ownerType,
            weekId = weekId,
            status = TaskStatus.PENDING,
            createdBy = userId,
            repeatTarget = null,
            repeatCompleted = 0,
            linkedGoalId = null,
            reviewNote = null,
            rolledFromWeekId = null,
            createdAt = Instant.DISTANT_PAST,
            updatedAt = Instant.DISTANT_PAST
        )

        taskRepository.createTask(task)

        _uiState.update { it.copy(showAddTaskSheet = false) }
        _sideEffects.send(WeekSideEffect.ShowSnackbar("Task added"))
    }
}
```

### TaskDeleteConfirmed

```kotlin
private fun handleTaskDeleteConfirmed() {
    val taskId = _uiState.value.selectedTaskId ?: return

    viewModelScope.launch {
        taskRepository.deleteTask(taskId)

        _uiState.update {
            it.copy(
                selectedTaskId = null,
                showDetailSheet = false
            )
        }
        _sideEffects.send(WeekSideEffect.ShowSnackbar("Task deleted"))
    }
}
```

---

## Data Observation

### Task Flow

```kotlin
private fun observeTasks() {
    viewModelScope.launch {
        combine(
            segmentPreferences.selectedSegment,
            weekRepository.observeWeek(weekRepository.getCurrentWeekId())
        ) { segment, week ->
            segment to week
        }.flatMapLatest { (segment, week) ->
            if (week == null) {
                flowOf(emptyList())
            } else {
                taskRepository.observeTasksByWeekAndOwnerType(
                    weekId = week.id,
                    ownerType = segment.toOwnerType(),
                    userId = userProvider.currentUserId
                )
            }
        }.collect { tasks ->
            updateTasksInState(tasks)
        }
    }
}

private fun updateTasksInState(tasks: List<Task>) {
    val userId = userProvider.currentUserId
    val partnerName = _uiState.value.partnerName

    val uiModels = tasks.map { task ->
        TaskUiModel.fromTask(task, userId, partnerName)
    }

    val incomplete = uiModels.filter { !it.isCompleted }
    val completed = uiModels.filter { it.isCompleted }

    _uiState.update {
        it.copy(
            tasks = uiModels,
            incompleteTasks = incomplete,
            completedTasks = completed,
            completedCount = completed.size,
            totalCount = uiModels.size,
            progressText = "${completed.size}/${uiModels.size}",
            isLoading = false
        )
    }
}
```

---

## State Flow Diagram

```
┌──────────────────────────────────────────────────────────────────┐
│                         WeekViewModel                             │
│                                                                   │
│  ┌─────────────────┐                    ┌─────────────────────┐  │
│  │ Segment         │◄───── observes ────│ SegmentPreferences  │  │
│  │ Preference      │                    │ (DataStore)         │  │
│  └────────┬────────┘                    └─────────────────────┘  │
│           │                                                       │
│           ▼                                                       │
│  ┌─────────────────┐                    ┌─────────────────────┐  │
│  │ TaskRepository  │◄───── observes ────│ observeTasksByWeek  │  │
│  │ .observe*()     │                    │ AndOwnerType()      │  │
│  └────────┬────────┘                    └─────────────────────┘  │
│           │                                                       │
│           ▼                                                       │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                    _uiState: MutableStateFlow                │ │
│  │                                                              │ │
│  │  WeekUiState(                                                │ │
│  │    weekInfo, selectedSegment, tasks, completedCount,        │ │
│  │    totalCount, quickAddText, isLoading, ...                  │ │
│  │  )                                                           │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                              │                                    │
│                              ▼                                    │
│                    uiState: StateFlow<WeekUiState>               │
│                              │                                    │
└──────────────────────────────┼───────────────────────────────────┘
                               │
                               ▼
                    ┌──────────────────┐
                    │   WeekScreen     │
                    │   Composable     │
                    └──────────────────┘
```

---

## Requirements Mapping

| Method/Flow | Spec Requirement | Notes |
|-------------|------------------|-------|
| observeTasks | FR-001, FR-002 | Grouped by status |
| handleTaskCheckboxTapped | FR-006, FR-008, FR-010 | Toggle + repeat |
| handleQuickAddSubmitted | FR-012, FR-013, FR-014 | Validation |
| handleSegmentSelected | FR-015, FR-016 | Persist preference |
| observeTasksByWeekAndOwnerType | FR-017, FR-019 | Filter by segment |
| sideEffects (haptic) | FR-007 | On completion |

---

## Error Handling

| Scenario | Handling |
|----------|----------|
| Empty title submission | Set `quickAddError` in state |
| Task not found | Log warning, no-op |
| Repository error | Set `error` in state, show snackbar |
| Network timeout | N/A (offline-first) |

---

## Thread Safety

- All state mutations via `_uiState.update { }` (atomic)
- Side effects via `Channel.BUFFERED` (thread-safe)
- Repository calls on IO dispatcher (handled by repository)
- UI collection on Main dispatcher

---

## Testing Contract

```kotlin
// ViewModel test example
@Test
fun `quick add with empty title shows error`() = runTest {
    // Given
    viewModel.onEvent(WeekEvent.QuickAddTextChanged(""))

    // When
    viewModel.onEvent(WeekEvent.QuickAddSubmitted)

    // Then
    assertThat(viewModel.uiState.value.quickAddError)
        .isEqualTo("Task title cannot be empty")
}

@Test
fun `task completion triggers haptic feedback`() = runTest {
    // Given
    val taskId = "task-123"

    // When
    viewModel.onEvent(WeekEvent.TaskCheckboxTapped(taskId))

    // Then
    val effect = viewModel.sideEffects.first()
    assertThat(effect).isEqualTo(WeekSideEffect.TriggerHapticFeedback)
}
```
